###对技术一定要有敬畏之心
###对编码一定要有工匠精神
###代码是写给人看的 顺便拿来给机器运行(扎入进细节 搞清原理 而不是能跑起来就行)
###能吃学习的苦  才不会去吃生活的苦
###vue相比于react要来的简单一点(语法!!!!)   生态圈和react一样  做复杂项目还是得深入vue
###有任何问题及时沟通

###复习
    1. vue配置
        el:
            --> el决定了根组件的挂载对象(挂载时并不会干掉挂载节点)
            --> el决定了根组件的模板
            注意点:
                el这个选项只有根组件才有拥有;子组件是没有办法拥有el选项的
            问题:
                子组件没有办法拥有el选项;那子组件怎么进行挂载? 子组件的模板怎么定义?
                     挂载: 通过组件的名字进行挂载(挂载时会干掉挂载节点)
                     模板: 新提供一个叫做template的选项 这个选项可以决定子组件的模板

        data
            ---> data中放的都是响应式数据
                根组件: data可以是一个对象
                子组件: data一定的是一个函数 函数返回的对象才是组件真正的数据
                        子组是会在不同的地方被使用多次的
                        我们希望子组件的数据 相互之间都是独立的

        methods
            ---> 放的是一些函数(大部分都是dom事件的回调函数)
                    方法一般都应该被定义在methods中;可是原则上data中也是可以定义方法的;
                    只是在data中定义方法 这些会被进行响应式处理 这是我们不希望看到的;
                    因为一个方法是不会在界面上做显示的;所以不需要做响应式;而且方法定义在
                    data中; 方法的this指向是有问题的;他会指向window 而不是当前组件

                    方法放在methods中;方法中的this就会指向vue实例对象(当前组件);而且还不会被做
                    响应式处理;提高渲染速度

        computed
            ---> 放的是计算属性
                什么时候使用计算属性?
                    当我们分析得到 在项目中一个数据需要依赖于data中其他数据时;我们就一个使用计算属性
                计算属性的特点?
                    计算属性的get方法会在vue初始化渲染的时候;被执行一次;
                    计算属性的get方法会在其依赖的属性产生变化时 再被执行一次
                    计算属性会使用缓存
                计算属性 vs 方法?
                    方法的缺点:   在vue初始化渲染的时候;被执行两次
                    方法的缺点:   任何一个data中的数据得到更新 导致界面渲染 方法就会被重新调用
                计算属性 vs 侦听器?
                    侦听器的缺点: 语法不灵活

                总结一下计算属性的语法:
                    computed:{
                        test(){} // 定义一个计算属性叫test 其get方法就是当前对应的函数
                        test:{
                            get(){} ,
                            set(val){} // val: 计算属性的值被直接更改时的那个值
                        }
                    }

        template
            ---> 决定任何组件的模板
               我们平常开发时;习惯使用template来确定子组件的模板
               根组件的模板 我们还是让el来决定

        watch
            ---> 配置侦听器


    2. vue实例对象
            一个vue实例就是一个vue组件
            属性
                $root
                $el
                $options
                $data
            方法
                $mount : 在el没有被指定的情况下;进行手动挂载
                $watch : 定义侦听器
                $set   : 为data添加额外的响应式数据的
            事件
                $on    : 为一个vue实例去注册vue自定义事件
                $once  : 为一个vue实例去注册vue自定义事件(一次性)
                $emit  : 触发vue自定义事件
                $off   : 解绑vue的自定义事件

    3. vue组件细节
            一个vue组件就是一个vue实例
            如果组件与html5的规范产生冲突时;我们可以使用is属性来解决冲突
            如果在vue组件上使用v-on: (@);这不是在定义原生的dom事件;而是在定义vue自定义事件
            <v-damu @click="handleClick" @damu="handleDamu"></v-damu>
                在vue的内部上述代码相当于:
                    找到v-damu这个组件(vue实例)
                        v-damu.$on("click",handleClick)  ---> v-damu.$emit("click")
                        v-damu.$on("damu",handleDamu)    ---> v-damu.$emit("damu")






